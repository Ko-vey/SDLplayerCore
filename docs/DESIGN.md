# SDLplayerCore 详细设计文档

本文档旨在深入阐述 `SDLplayerCore` 的内部架构、线程模型和核心功能的实现细节。

> 本项目的架构图和流程图使用 [Draw.io](https://www.drawio.com/) 绘制。
> 在文档中直接展示的插图为 `.svg` 图片文件，对应的同名源文件 (`.drawio` 及 部分以 `.md` 格式储存的 `mermaid` 源代码) 存放在 `docs/assets/` 目录下。
> 如需修改，请优先编辑 `.md` 文件中的 `mermaid` 源代码、并将其导入`.drawio` 源文件、调整后导出为 `.svg` 图片文件，更新文档内的插图对应文件路径，然后将各个新文件一并提交。

## 目录

- [SDLplayerCore 详细设计文档](#sdlplayercore-详细设计文档)
  - [目录](#目录)
  - [1. 总体架构与数据流](#1-总体架构与数据流)
  - [2. 核心机制实现](#2-核心机制实现)
    - [2.1 缓存队列和流量控制逻辑](#21-缓存队列和流量控制逻辑)
      - [2.1.1 核心设计](#211-核心设计)
      - [2.1.2 线程交互机制](#212-线程交互机制)
        - [场景一：生产者在队列已满时尝试推入数据](#场景一生产者在队列已满时尝试推入数据)
        - [场景二：消费者在队列为空时尝试取出数据](#场景二消费者在队列为空时尝试取出数据)
    - [2.2 音视频同步逻辑](#22-音视频同步逻辑)
      - [2.2.1 引言](#221-引言)
      - [2.2.2 核心设计](#222-核心设计)
      - [2.2.3 线程交互机制](#223-线程交互机制)
        - [(一) 时钟同步逻辑](#一-时钟同步逻辑)
        - [(二) 视频渲染线程 - 自主刷新防黑屏机制](#二-视频渲染线程---自主刷新防黑屏机制)
      - [2.2.4 ClockManager 实现要点](#224-clockmanager-实现要点)
    - [2.3 播放/暂停机制](#23-播放暂停机制)
    - [2.4 优雅退出机制](#24-优雅退出机制)


## 1. 总体架构与数据流

本项目采取了类似 [`ffplay`](https://github.com/FFmpeg/FFmpeg/blob/master/fftools/ffplay.c) 的经典"生产者-消费者"架构，通过多线程实现模块间的解耦与并行处理。播放器的核心模块与数据流示意图如下:

![核心模块与数据流图](assets/pic2-basic_architecture.svg)

每个模块都有各自明确的任务:

1. **解复用模块 (Demuxer)**: 负责读取媒体文件（如 MP4, MKV），解析其容器格式，并将分离出的音频、视频压缩数据包 (`AVPacket`、`AVFrame`) 分别送入对应的缓存队列中。

2. **缓存队列模块 (Queue)**: 作为线程间数据交换的缓冲池，用于存放 `AVPacket` 和 `AVFrame`。它解决了生产者与消费者速率不匹配的问题，并提供了必要的线程安全与同步机制。本项目中的 `PacketQueue` (数据包队列) 和 `FrameQueue` (数据帧队列) 在设计上基本一致。

3. **视频解码模块 (Video Decoder)**: 从视频包队列 (`VideoPacketQueue`) 中获取 `AVPacket`，利用 FFmpeg 解码器将其解码为原始视频数据帧 (`AVFrame`)，然后将 `AVFrame` 放入视频帧队列 (`VideoFrameQueue`)。

4. **视频渲染模块 (Video Renderer)**: 从视频帧队列 (`VideoFrameQueue`) 中获取 `AVFrame`，根据同步时钟决定最佳渲染时机。在渲染前，需要通过 `sws_scale` 进行色彩空间转换（从 `AVFrame` 到 YUV）。最终使用 SDL2 的渲染函数将图像绘制到窗口上。

5. **音频解码模块(Audio Decoder)**: 从音频包队列 (`AudioPacketQueue`) 中获取 `AVPacket`，利用 FFmpeg 解码器将其解码为原始音频数据帧 (`AVFrame`)，然后将 `AVFrame` 放入音频帧队列 (`AudioFrameQueue`)。

6. **音频渲染模块 (Audio Renderer)**: 从音频帧队列 (`AudioFrameQueue`) 中获取 `AVFrame`。如果解码后的音频格式（如采样率、声道数）与设备不符，会通过 `swr_convert` 进行重采样。最终，将处理好的 PCM 数据推送给 SDL 的音频缓冲区进行播放。

7. **同步时钟模块 (Clock Manager)**: 负责统一管理播放时间。通常以音频时钟为主时钟（因为人耳对音频的延迟更敏感），当无法获取音频时使用外部时钟（SDL2提供的系统时钟）；视频通过比对自身的显示时间戳 (PTS) 与主时钟来调整播放节奏（延迟、跳帧或加速），从而实现音视频同步。

这些模块被集成在主类 `MediaPlayer` 中，通过初始化辅助函数 `MediaPlayer::start_threads` 和 主循环函数 `MediaPlayer::runMainLoop` 启动各个工作线程，并通过定时轮询的事件处理机制 `MediaPlayer::handle_event` 来响应用户的交互操作。

更细节具体的模块交互时序图如下:

![核心模块交互时序图](assets/pic3-detailed_core_architecture.svg)

在各个线程中，每个模块都通过对应的接口执行相应关键任务:

**1.  解复用线程 (Demux Thread)**: 

- 通过 `avformat_open_input` 打开媒体文件并用 `avformat_find_stream_info` 读取流信息。在主循环中，反复调用 `av_read_frame` 从文件中读取数据包 (`AVPacket`)，并根据其流索引，分别推入音频或视频的 `PacketQueue` 中。

**2.  视频解码线程 (Video Decode Thread)**: 

- 循环地从 `PacketQueue` 中取出 `AVPacket`，通过 `avcodec_send_packet` 将其发送给解码器。然后，通过 `avcodec_receive_frame` 接收解码完成的 `AVFrame`，并将其存入 `FrameQueue` 以供渲染线程使用。

**3.  视频渲染线程 (Video Render Thread)**: 

- 循环地从 `FrameQueue` 中取出 `AVFrame`。根据该帧的 PTS 和同步时钟的当前时间，计算出需要延迟的时间并等待。之后，使用 `sws_scale` (如果需要) 进行图像格式转换，再调用 `SDL_UpdateYUVTexture`, `SDL_RenderCopy`, `SDL_RenderPresent` 等函数将图像更新并显示在窗口上。

**4. 音频解码线程 (Audio Decode Thread)**:

- 与视频解码线程类似。循环地从音频 `PacketQueue` 中取出 `AVPacket`，通过 `avcodec_send_packet` 和 `avcodec_receive_frame` 解码出 `AVFrame`，并将其存入音频 `FrameQueue`。

**5. 音频渲染线程 (Audio Render Thread)**:

- 循环地从 `FrameQueue` 中取出 `AVFrame`，使用 `swr_convert` (如果需要) 进行重采样后，调用 `SDL_QueueAudio` 将 PCM 数据推入播放队列，并根据推送的数据量精确更新主时钟。


## 2. 核心机制实现

### 2.1 缓存队列和流量控制逻辑

在多线程音视频播放器中，各个处理阶段（如解复用、解码、渲染）运行在独立的线程上。为了高效、稳定地在这些线程间传递数据，并协调它们的生产和消费速率，一个健壮的线程安全缓存队列是整个并发架构的基础。

在本项目中，设计并实现了 `PacketQueue` 和 `FrameQueue`（两者设计思想和结构类似，本章以 `PacketQueue` 为例），它们是基于生产者-消费者模式的高度并发组件。其核心职责是：

- **线程解耦**：允许解复用线程、解码线程和渲染线程独立运行，避免因某个阶段的瞬时阻塞（如I/O等待、解码耗时）而导致整个播放器停滞。

- **流量控制**：通过设置队列的最大容量 (`max_size`)，实现“背压”机制（Back-pressure）。当队列满时，生产者（如解复用线程）会自动阻塞，等待消费者取走数据，从而防止内存无限增长。反之，当队列为空时，消费者会阻塞，等待生产者放入数据。

- **生命周期管理**：通过一个原子性的 `eof_signaled` 标志，实现对数据流结束（EOF, End-of-File）的精确控制，确保所有线程都能在数据处理完毕后正常、有序地退出。

#### 2.1.1 核心设计

`PacketQueue`的并发安全和流量控制主要依赖于以下C++标准库组件：

- **std::mutex**：互斥锁，用于保护共享资源（即内部的 `std::queue`），确保任何时候只有一个线程能修改队列。

- **双条件变量** (`std::condition_variable`)：

  - `cond_producer`: 当队列已满时，用于阻塞生产者线程。

  - `cond_consumer`: 当队列为空时，用于阻塞消费者线程。
  
    使用两个独立的条件变量可以避免不必要的线程唤醒（例如，`push` 操作只应该唤醒等待数据的消费者，而不是等待空间的生产者）。

- **循环检查 (`while`循环)**：在调用 `wait()` 时，使用 `while` 循环来重新检查条件 (`while (queue.size() >= max_size)`)。这是为了防止“虚假唤醒”（Spurious Wakeups），确保线程被唤醒后，其等待的条件确实已满足。

- **EOF信令**：`signal_eof()` 方法通过设置 `eof_signaled` 标志并调用 `notify_all()`，可以唤醒所有正在等待的生产者和消费者线程。这些线程被唤醒后，会检查到 `eof_signaled` 为 `true`，从而能够优雅地退出其工作循环，结束线程。*这一部分内容见 [2.4 优雅退出机制](#24-优雅退出机制)。*

#### 2.1.2 线程交互机制

下面通过UML序列图来展示两个核心场景下的线程交互逻辑。

##### 场景一：生产者在队列已满时尝试推入数据

此场景展示解复用线程（生产者）如何因为视频 `Packet` 队列已满而阻塞，直到视频解码线程（消费者）消费了一个 `Packet` 后，生产者才被唤醒并继续执行。

下面的序列图展示了具体的线程交互过程，重点描绘了生产者等待及被消费者唤醒的情况。

![缓存队列对生产者的阻塞-示意图](assets/pic4-queue_producer_block.svg)

这是一个多线程“生产者-消费者”模型的典型场景，**具体参与者**如下：
- **生产者 (Producer)**: `DemuxThread` (解复用线程)，通过调用 `push()` 方法生产数据。
- **消费者 (Consumer)**: `VideoDecodeThread` (视频解码线程)，通过调用 `pop()` 方法消费数据。
- **队列 (Queue)**: `PacketQueue` 实例，负责管理数据和同步。
- **同步原语 (Synchronization Primitives)**:
    - `std::mutex`: 互斥锁，保护队列内部数据（`std::queue`）的互斥访问，由`unique_lock`管理。
    - `std::condition_variable` (`cond_producer`): 条件变量，当队列已满时，用于阻塞生产者线程。

**同步机制和线程交互逻辑如下：**

**1. 生产者尝试推送数据**:

- 生产者 `DemuxThread` 调用 `PacketQueue` 的 `push` 方法，希望放入一个数据包。`PacketQueue` 的生命线被激活，开始执行 `push` 方法。

**2. 通过RAII获取锁**:

- 进入 `push` 函数后，代码首先创建一个 `std::unique_lock` 实例 (`lock`)。这体现了C++的 **RAII (资源获取即初始化)** 原则：`lock` 对象在**构造时**会自动锁定其管理的 `mutex`。这确保了在 `push` 函数的后续作用域内，队列访问是线程安全的。

**3. 检查等待条件**:

- 在持有锁的情况下，线程进入 `while` 循环检查条件 (`queue.size() >= max_size`)。由于此时队列已满，条件为真，生产者不能立即推入数据，必须等待。

**4. 生产者等待并原子性地释放锁**:

- 生产者调用 `cond_producer.wait(lock)`，将 `lock` 管理器作为参数传入。这是一个关键**原子操作**，它能保证：
  - **自动释放** `lock` 所管理的 `mutex`。
  - **阻塞**当前生产者线程，使其进入等待状态。
- 图中 `lock` 的生命线暂时失活，表示锁已被释放，从而允许其他线程（如消费者）获取它。

**5. 并发的消费者操作**:

- 在生产者线程等待期间，另一个 `VideoDecodeThread` (消费者) 线程可以自由执行。它会调用 `pop()` 方法，成功获取同一个互斥锁（因为生产者已在 `wait` 中释放了它），从队列中取出一个元素，然后调用 `cond_producer.notify_one()`。此调用会发送一个信号，旨在唤醒一个正在等待“队列已满”条件的生产者线程。

**6. 生产者被唤醒并重新获取锁**:

- 接收到消费者的通知后，生产者线程被唤醒。`wait(lock)` 函数在**返回之前**，会**自动重新获取**它之前释放的锁。`lock` 的生命线被重新激活。
- `wait` 函数返回后，代码从 `while` 循环的头部继续执行，**再次检查条件**。这是为了防止“虚假唤醒”。此时队列已有空间，条件为假，循环退出。

**7. 生产者完成数据推送**:

- 循环退出后，生产者成功将新的数据包 (`pkt_clone`) 推入队列。

**8. 提前解锁以提高并发**:

- 在通知消费者之前，代码显式调用 `lock.unlock()` **提前手动释放锁**。这是一个性能优化，可以减小锁的持有时间（即减小锁的粒度），从而允许其他线程（如另一个消费者）能够更快地访问队列，从而提高整体并发性能。`lock` 的生命线再次失活。

**9. 通知消费者并返回**:

- 在释放锁之后，生产者调用 `cond_consumer.notify_one()` 来通知任何可能因“队列为空”而等待的消费者线程。
- 最后，`push` 方法执行完毕，向生产者 `DemuxThread` 成功返回。

##### 场景二：消费者在队列为空时尝试取出数据

此场景展示视频解码线程（消费者）如何因为 `Packet` 队列为空而阻塞、暂停工作，并带有超时机制。

下面的序列图展示了具体的线程交互过程，重点描绘了消费者等待及两种主要情况（超时或被生产者唤醒）。

![缓存队列对消费者的阻塞-示意图](assets/pic5-queue_thread-consumer_block.svg)

在这一场景中，**具体参与者**如下:
  - **生产者 (Producer)**: `DemuxThread` (解复用线程)。
  - **消费者 (Consumer)**: `VideoDecodeThread` (视频解码线程)。
  - **队列 (Queue)**: `PacketQueue` 实例。
  - **同步原语 (Synchronization Primitives)**:
      * `std::mutex`: 互斥锁，由`unique_lock`管理。
      * `std::condition_variable` (`cond_consumer`): 条件变量，在队列为空时用于阻塞消费者线程。

**同步机制和线程交互逻辑如下：**

1.  **获取锁**: `pop()` 方法首先通过 `std::unique_lock` 获取互斥锁 `mutex`，确保后续操作的线程安全。
  
2.  **条件检查**: 进入一个 `while` 循环，检查 `queue.empty() && !eof_signaled`。
      - 使用 `while` 而非 `if` ，以防止**虚假唤醒**。即使线程被唤醒，也必须重新检查条件，确保是真正有数据可取，而不是意外唤醒。
      - `!eof_signaled` 条件确保在数据流结束（EOF）的信号发出后，线程不会无限等待。

3.  **进入等待**: 由于条件为真（队列为空），线程会调用 `cond_consumer.wait_for(lock, std::chrono::milliseconds(100))`。
      - 这个调用会**原子性地**做两件事：释放它持有的 `lock`；将当前线程置于阻塞（等待）状态。
      - 释放锁很重要，否则生产者线程将永远无法获得锁来推入新数据，造成死锁。
  
4.  **等待结束与结果分支**: 等待状态会因以下两种情况之一而结束：
      - **分支 A (超时)**: 
        - 如果在指定的100毫秒内没有被其他线程唤醒，`wait_for` 将超时并返回 `std::cv_status::timeout`。`pop()` 方法捕获到这个状态后，会立即返回 `false`。消费者线程 (`video_decode_func`) 收到 `false` 后，会继续其主循环，并在下一个周期再次尝试 `pop`，这构成了一种高效的、带超时的轮询。
      - **分支 B (被唤醒)**:
        - **被生产者唤醒**: 生产者（`DemuxThread`）成功推入一个数据包后，会调用 `cond_consumer.notify_one()`。
        - **被EOF信号唤醒**: `DemuxThread` 检测到文件末尾或发生错误，会调用 `signal_eof()`，该函数会调用 `cond_consumer.notify_all()`。
        - 在这两种情况下，等待的消费者线程被唤醒。它会重新尝试获取 `lock`，一旦成功，`wait_for` 调用结束。线程会回到 `while` 循环的顶部，再次检查条件。如果队列中已有数据或已收到EOF信号，循环将退出，程序继续执行后续的数据提取逻辑。
  
5.  **返回结果**:
      - 在超时情况下，`pop()` 返回 `false`。
      - 在被成功唤醒并取出数据后，`pop()` 将数据拷贝到调用者提供的 `packet` 中，并返回 `true`。


### 2.2 音视频同步逻辑

#### 2.2.1 引言

在音视频播放器中，解复用、解码、渲染等核心处理阶段运行在各自独立的线程中。通常，音频处理管线的速度快于视频，因此，为了实现协调、流畅的播放体验（即“音画同步”），必须设计并实现一个可靠且健壮的同步时钟模块。

本项目采用“**音频时钟为主，外部时钟为辅**”的同步策略。为此，设计并实现了 `ClockManager` 组件，它作为播放器的“心跳”，统一管理和分发时间基准。其核心职责是：

- **提供主时钟**：当存在音频流时，以音频的播放进度作为主时钟；否则，回退到外部系统时钟。

- **计算精确的音频时间**：通过音频帧的显示时间戳（PTS）和SDL音频设备中缓冲的数据量，精确计算出当前正在被听到的音频时间点。

- **跟踪各流时钟**：分别记录视频和音频流的最新时间戳。

- **管理播放状态**：处理暂停和恢复逻辑，确保时钟在暂停时“冻结”，在恢复时能无缝续上。

#### 2.2.2 核心设计

| 组件                    | 线程                          | 关键职责                                                                                |
| ----------------------- | ----------------------------- | --------------------------------------------------------------------------------------- |
| **ClockManager**        | / (无主动线程)                | 提供 音频时钟、视频时钟 及 外部时钟 的统一读写接口，并计算主时钟(*MasterClock*)           |
| **SDLAudioRenderer**    | Audio Render Thread           | 在音频帧写入SDL队列(`SDL_QueueAudio`)前更新 AudioClock(`setAudioClock(pts)`)            |
| **SDLVideoRenderer**    | Video Render Thread           | 读取主时钟，计算时间差delay，做同步决策并渲染                                            |
| **FrameQueue\<Video>**  | / (无主动线程，生产/消费并行)  | 提供带超时的 `pop(timeout=100 ms)`，让视频线程在无帧时能退出等待、自主刷新，防止无效等待  |
| **MainLoop (GUI)**      | Main 主线程                   | 周期为1s的定时器 → 执行 `refresh()` 来避免黑屏                                           |

#### 2.2.3 线程交互机制

##### (一) 时钟同步逻辑

音视频同步是播放器**最核心且复杂**的算法之一。本项目采用**以音频时钟为主、外部时钟为辅**的策略：

1. **音频线程**在把 PCM 数据送入 `SDL_QueueAudio` 之前，实时调用 `ClockManager::setAudioClock()` 写入最新 PTS，并由 `ClockManager::getAudioClockTime()` 精确扣除仍在缓冲区中的未播放时长。
2. **视频线程**在准备渲染每一帧时，通过 `ClockManager::getMasterClockTime()` 取得主时钟，与自身帧 PTS 计算差值 `delay`，决定**等待 / 立即渲染 /（可选）丢帧**。
3. 当没有音频流或用户主动关闭声音时，`ClockManager` 自动退化为 **外部时钟**（基于 `SDL_GetTicks64()` 的高精度计时器），保证纯视频文件也可以正确播放。

下面展示主时钟驱动的音画同步线程交互图：

![音画同步机制的线程交互图](assets/pic6-audio_video_sync_thread.svg)

**事件说明：**

| # | 说明                                                                                                |
| - | -------------------------------------------------------------------------------------------------- |
| 1 | **音频渲染线程**在每次向 SDL 推送数据前调用 `setAudioClock()`——这是主时钟唯一可信的数据源。          |
| 3 | **视频渲染线程**采用带 100 ms 超时的 `pop()`，可避免因上游数据不稳定（如抖动或暂停）导致的永久卡死。  |
| 7 | `delay` 决定“等待”还是“快一点”；阈值 40 ms ～ 100 ms 既能过滤细小抖动，又不会造成明显卡顿。           |
| 9 | 若长时间拿不到帧或 GPU 纹理被系统丢弃，调用 `refresh()` 用最后一帧内容“救屏”。                        |

**核心决策逻辑：**

1. **音频 → 时钟**：音频渲染线程 `AudioRenderThread` 在*真正*送入 SDL 播放前写时钟(`ClockManager.setAudioClock()`)，保证主时钟精度随播放进度实时后移。
2. **视频 → 时钟**：视频线程**只读**时钟，不修改主时钟，防止时钟失真。
3. **核心决策逻辑 - 阈值策略**
   - 获取主时钟: `master_clock = ClockManager.getMasterClockTime()`
   - 计算延迟: `delay = frame_pts – master_clock` (秒)
   - 同步策略：
     - 阈值：`AV_SYNC_THRESHOLD_MIN` = 40 ms，`AV_SYNC_THRESHOLD_MAX` = 100 ms
     - 若 `delay > 0`：等待 `min(delay, AV_SYNC_THRESHOLD_MAX)`；
     - 若 `delay < -AV_SYNC_THRESHOLD_MIN`：可选择丢帧（当前实现始终渲染，优先保真）。
4. **非同步保护**：若 `|delay| > 10 s` → 时钟失真，`delay`直接置 0 ；防止时钟漂移，并避免进度跳转(seek)后出现长时间黑屏或卡死。

##### (二) 视频渲染线程 - 自主刷新防黑屏机制

为了提升用户体验，防止在特定场景下（如暂停、缓冲或窗口被系统回收 GPU 资源、锁屏等）视频渲染线程可能因为长时间拿不到新帧、而让播放器窗口出现黑屏，本播放器实现了一套双层防御的自主刷新机制。

**核心痛点:**

- **内容空窗期**：当播放暂停或视频解码因处于缓冲状态而暂时没有新帧送达时，如何避免画面静止不动或黑屏。

- **外部环境干扰**：当用户锁屏、最小化窗口或切换到其他应用时，操作系统可能会回收GPU资源导致纹理内容丢失。当窗口恢复时，如何避免黑屏。

“双层防御机制”(主防线+后备防线) 的两层防线如下：

| 层级          | 入口 & 周期                             | 触发条件                                                        | 行为                          |
| ------------- | --------------------------------------- | -------------------------------------------------------------- | ----------------------------- |
| **主防线**    | `video_render_func`循环，周期 ≤ 100 ms  | `pop` 超时 && (`current − last_refresh > 500 ms` 或 窗口可见)   | `SDLVideoRenderer::refresh()` |
| **后备防线**  | `runMainLoop` 主线程，周期 ≈ 1000 ms      | 定期检测窗口状态                                                | 同上                          |

视频渲染线程的自主刷新机制的决策流程图如下：

![视频渲染线程自主刷新机制-流程图](assets/pic7-video_render_refresh_flowchart.svg)

#### 2.2.4 ClockManager 实现要点

| 接口                          | 关键公式 / 行为                                                             |
| ----------------------------- | ------------------------------------------------------------------------- |
| `setAudioClock(pts)`          | 仅存储最新音频帧的 PTS                                                      |
| `getAudioClockTime()`         | `pts - (SDL_GetQueuedAudioSize / bytesPerSec)`                             |
| `getExternalClockTime()`      | `(SDL_GetTicks64 - start_time) / 1000`（暂停时固定）                        |
| `getMasterClockTime()`        | `prefer AUDIO` && `has_audio_stream` → AudioClock；否则使用 ExternalClock   |
| `setVideoClock(pts,duration)` | 记录视频时钟以供调试，可辅助 音频/视频 质量评估                                |

音画同步中的关键类 `ClockManager` 通过轻量互斥锁与 `std::atomic<bool> m_paused`，保证多线程安全且暂停/恢复切换迅速。


### 2.3 播放/暂停机制



### 2.4 优雅退出机制


